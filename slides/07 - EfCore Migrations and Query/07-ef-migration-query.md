<!-- .slide: data-background="#003d73" -->
## EF Migrations

![AU Logo](./../img/aulogo_uk_var2_white.png "AU Logo") <!-- .element style="width: 200px; position: fixed; bottom: 50px; left: 50px" -->

----

### Agenda

* Migration The why, what, where
    * First migration
    * Update database
    * Rolling back migrations
* Query
    * Loading strategies
    * Tracing
    * Create / Update

---

## What is migrations

1. Technic EfCore uses to track of changes in database schema
2. Files that EfCore uses to create schema


----

## Why migrations

* Avoid making changes by hand
* It's not a feasible to delete database every time we make a change
    * keeping environments in sync
    * e.g Development, Staging and Production 


----

### Benefits of migrations

* Files generated by EfCore based on your OOP models
  * and track changes
* Keeps OOP model and database tables in sync
* Edit database schema without losing data* (development and production)
* Provide a way to make rollbacks on database (like with VCS)

&#8594; **Basicly**: Version control for database

\* Most of the time <!-- .element style="font-size: 22px" -->

----

### Drawback of migrations

* Harder to make merges in larger teams.
  * *migrations files should be handled especially carefully*
  * **more** on this when IteratorIT visit us in week 43

note:
TODO: clean up after lecture

----

### Where do migrations live (1/2)

In: <project-folder>/Migrations/"

Migrations file: 
```csharp
public partial class AddContactPhoneNumber : Migration {
    protected override void Up(MigrationBuilder mb) {
        mb.AddColumn<string>(
            name: "PhoneNumber",
            table: "Contacts",
            nullable: true);
    }

    protected override void Down(MigrationBuilder mb) {
        mb.DropColumn(
            name: "PhoneNumber",
            table: "Contacts");
    }}
```

----

### Where do migrations live (2/2)

<ContextClassName>ModelSnapshot.cs:

```csharp
protected override void BuildModel(ModelBuilder mb) {
  #pragma warning disable 612, 618
  mb.HasAnnotation("ProductVersion", "2.2.0-rtm-35687");
  mb.Entity("MyFirstEfCoreApp.Models.Contact", b => {
          b.Property<int>("Id")
              .ValueGeneratedOnAdd();
          b.Property<string>("Email");
          b.Property<string>("FirstName");
          b.Property<string>("LastName");
          b.Property<string>("PhoneNumber");
          b.HasKey("Id");
          b.ToTable("Contacts");
      });
      ...}
```

---

## Create migration

* In Visual Studio (open Package Manager Console)
    ```
    PM> Add-Migration <MigrationName>
    ```
* .Net Core cli
    ```
    $ dotnet ef migrations add <MigrationName>
    ```
* Creates a .cs file with timestamp and name of migration + plus creates/updates Snapshot.cs file in Migrations folder.

----

### Update database

* In Visual Studio (open Package Manager Console)
    ```
    PM> Update-Database
    ```
* .Net Core cli
    ```
    $ dotnet ef database update
    ```
* After this the migration(s) is **applied**

**Hint**: Apply each migrations instead of mass applying a bunch of migrations  

----

### Migrations

![Multiple migrations](./img/multiple-migrations.png)

---

## Demo

![Demo](./img/demo.jpeg "Demo time") <!-- .element style="height: 500px" -->

---

### Rollback migrations (undo) - in unapplied state

* In Visual Studio (open Package Manager Console)
    ```
    PM> Remove-Migration
    ```
* .Net Core cli
    ```
    $ dotnet ef migrations remove
    ```

----

### Rollback migrations (undo) - in applied state

* In Visual Studio (open Package Manager Console)
    ```
    PM> Update-Database <MigrationName-1>
    PM> Remove-Migration
    ```
* .Net Core cli
    ```
    $ dotnet ef database update <MigrationName-1>
    $ dotnet ef migrations remove
    ```

Until you are at <MigrationName-1>

note:

Remove all migrations 

PMC: `PM> Update-Database 0`

cli: `$ dotnet ef database update 0`

----

### What happens

1. If migrations is applied
    * database will execute `Down()`
2. Remove migrations
    * deletes the migrations file
3. Then you can change your models  

---

<!-- .slide: data-background-image="./img/crud.png" -->

----

### Create

```csharp
static void CreateBook(MyDbContext context, string isbn,
               string title, Author author) {
    var book = new Book() {
        Isbn = isbn,
        Title = title,
        Author = author
    };

    context.Add(book);
    context.SaveChanges();
}
```

* We **do not** touch database is, primary or foreign
* EF Core expects primary key with SQL IDENTITY
* Primary keys which are eg. GUID should be created with ValueGenerator


Note: 

paulChiusano - is an object of type Author

```csharp
public class Book
{
    public int BookId { get; set; }
    
    public string Isbn { get; set; }
    public string Title { get; set; }
    public Author Author { get; set; }
    public List<Review> Reviews { get; set; }
}
```

----

### Update

* Without `AsNoTracking` - data can be changed:
```csharp
static void UpdateBook(MyDbContext context,
                     string title, string isbn)
{
    var book = context.Book
                  .Single(p => p.Title == title);
    book.Isbn = isbn;

    context.SaveChanges();
}
```
* When `SaveChanges()` is executed, the EF method `DetectChanges` which compare snapshot with application copy


----

![Change detections](./img/changes.png) <!-- .element style="height:500px" -->

----

### Delete

```csharp
static void DeleteData(MyDbContext context, string isbn)
{
    var book = context.Book.Single(b => b.Isbn == isbn);
    context.Remove(book);

    context.SaveChanges();
}
```

----

### Manipulating content

* Multiple save/delete/update statements can be made in a single `SaveChanges()`
* `SaveChanges` vs `SaveChangesAsync`


---

## Read

![Read](./img/read.jpeg "")

----

## Querying

* Access via DbContext

```csharp [1|2|3]
var theArtQuery1 = context.Book
          .Where(b => b.Title.StartsWith("The Art"));
var theArtBooks1 = theArtQuery1.ToList();
```

vs

```csharp
var theArtBook2 = 
      from b in context.Book
        where b.Title.StartsWith("The Art")
        select b;
```

**Note**: Requires using of `LINQ` and `EntityFrameworkCore`

Note:

1. DbContext property accces
2. A series of LINQ and/or EF core commands
3. An execute command

----

### Execute commands

* `.ToList()`
* `.ToArray()`
* `.Count()`
* ...

----

### Async execution

* Ends with `Async()`
  * e.g. `.ToListAsync()`
  * will not block callers thread
* Exists in `EntityFrameworkCore` namespace - remember `using`
  * exists as extensions methods
* *Limitation*: Not parallel queries on same `DbContext` instance


note:

Extension methods:

```csharp
namespace ExtensionMethods
{
    public static class MyExtensions
    {
        public static int WordCount(this string str)
        {
            return str.Split(new char[] { ' ', '.', '?' },
                             StringSplitOptions.RemoveEmptyEntries).Length;
        }
    }
}
```

----

### Async in C#

* Returns a `Task<A>`
* Use async and await - we will come to that in SWD

```csharp
var review = new Review()
{
    Book = book,
    Rating = 3,
};
context.Add(review);
await context.SaveChangesAsync();
var reviews = await context.Review.ToListAsync();
```

----

## Tracking

To `Track`

```csharp
context.Book.ToList()
```

or to `NoTrack`

```csharp
context.Book.AsNoTracking().ToList()
```

* `AsNoTracking` gives better performance in readonly scenarios


---

## Read Strategies

![Stategies](./img/strategies.jpeg "")

----

### Round-trips

![Round trips](./img/round-trip.png) <!-- .element style="height:500px" -->

----

## Loading Strategies - Explicit

```csharp
async Task<IEnumerable<Book>> ReadAllBooksWithAuthorExplicit(MyDbContext myDbContext)
{
    var books = await myDbContext.Book.ToListAsync();
    foreach (var book in books) {
        await myDbContext.Entry(book).Reference(b => b.Author).LoadAsync();
    }
    return books;
}
```

* #43; Load relationship when needed
* % More database round-trips
* Usage:
    * e.g. when library only returns primary entity
    * Data only used in some circumstances, so we only load needed data

Note:

```csharp
public class Book {
    ...
    public Author Author {get; set;} //  Navigational property
}
```

----

### Loading Strategies - Eager

```csharp
async Task<IEnumerable<Book>> ReadAllBooksEager(MyDbContext myDbContext)
{
    return await myDbContext.Book
        .Include(b => b.Author)
        .Include(b => b.Reviews)
        .ToListAsync();
}
```

* &#43; Loaded by EF Core efficiently with a minimum of round-trips
* &#37; Load all data, even when not needed
* If relationship does not exists, EF does not fail
* Since 3.0 this uses JOIN extensively - Be AWARE

Note:

```csharp
public class Book
{
    public int BookId { get; set; }
    
    public string? Isbn { get; set; }
    public string? Title { get; set; }
    public Author? Author { get; set; }
    public List<Review> Reviews { get; set; } = new List<Review>();
}
```

----

### Loading Strategies eager - multiple levels

```csharp
async Task<IEnumerable<Book>> ReadAllBooksEagerMultipleLevels(MyDbContext myDbContext)
{
    return await myDbContext.Book
        .Include(b => b.Author)
        .Include(b => b.Reviews)
         .ThenInclude(r => r.Voter)
        .ToListAsync();
}

```

* ThenInclude can be chained

Note:

```csharp
public class Review
{
    public int ReviewId { get; set; }
    public int Rating { get; set; }
    
    public int BookId { get; set; }
    public Book? Book { get; set; }

    public int? VoterId { get; set; }
    public Voter? Voter { get; set; }
}
```

----

### Loading Strategies - Select

```csharp
async Task<IEnumerable<object>> ReadAllBooksSelect(MyDbContext myDbContext) {
    return await myDbContext.Book
        .Select(b => new {
            b.Title,
            b.Isbn,
            NumReview = b.Reviews.Count
    }).ToListAsync();
}
```

* \+Load specifically the data needed, including database calculations
* % Have to write each query by hand

**Note**: Includes are ignored when returning instances, which are not an entity type

Note:
Use LINQ to create anonymous objects with specific data


----

### Loading Strategies - Lazy (1/2)

**With Proxies**

1. Install NugetPackage 'Microsoft.EntityFrameworkCore.Proxies'
1. Enable proxies in DbContext
```csharp
public class Context : DbContext {
    protected override void OnConfiguring(
                    DbContextOptionsBuilder optionsBuilder) => 
        optionsBuilder
            .UseLazyLoadingProxies()
            .UseSqlServer(myConnectionString); 
}
```

----

### Loading Strategies - Lazy (2/2)

**With `LazyLoader`**

1. Or by injecting `LazyLoader` into service<br/>This enables lazy loading of navigational properties that can be overridden. 
2.  Requires that all navigational properties are declared virtual

```csharp
public class Book
{
    ...
    public List<Review> Reviews { get; set; } = new List<Review>();
}
```


```csharp
public BookServices(ILazyLoader layzyLoader)
```

---

## Exercises :)

<!-- .slide: data-background="./img/make-homework-fun.jpg" -->

----

## References